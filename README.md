# README.md8
# Python Functions
# Functions in Python
A function is a named section of a code that performs a specific task. This typically involves taking some input, manipulating it and returning an output.

# class method vs static -method in Python
A static method requires no specific parameters, a class method takes cls as its first argument. While a static method cannot access or modify the class state, a class method can. Static methods are typically unaware of the class state.

# Write an empty function in Python â€“ pass statement
In Python, to write empty functions, we use pass statement. pass is a special statement in Python that does nothing. It only works as a dummy statement.

# Yield instead of Return
We should use yield when we want to iterate over a sequence, but don't want to store the entire sequence in memory. Yield are used in Python generators.

# Return Multiple Values
Python also allows us to return multiple values using lists or dictionaries. This can be useful when the values are related or when we want to keep them together.

# Partial Functions in Python
Python Partial is a higher-order function that takes a function as its first input and returns a function that can be used as any other function in the program. Partial functions support both positional and keyword arguments to be used as fixed arguments.

# First Class functions in Python
Created at runtime. Assigned to a variable or element in a data structure. Passed as an argument to a function is called First Class function.

# Precision Handling
Precision Handling reduces the risk of deteriorating sample integrity to a minimum. Manual storage of samples is replaced by a fully automated storage systems with single tube picking. Automated storage solutions are a quantum leap in documentation and quality of frozen samples.

# *args and **kwargs
The *args specifies the number of non-keyworded arguments that can be passed and the operations that can be performed on the function in Python, whereas. **kwargs is a variable number of keyworded arguments that can be passed to a function that can perform dictionary operations.

# Python closures
A Closure is a function object that remembers values in enclosing scopes even if they are not present in memory.

# Function Decorators
A decorator is a design pattern in Python that allows a user to add new functionality to an existing object without modifying its structure. Decorators are usually called before the definition of a function you want to decorate.

# Decorators in Python
Decorators are a powerful and elegant feature in Python that allows you to modify or extend the behavior of functions or methods without changing their actual code.

# Decorators with parameters in Python
Python functions that allow you to wrap another function as an input and modify its behavior without altering the wrapped function's code

# Memoization using decorators in Python
. Memoization is an optimisation technique used to speed up programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.

# Help function in Python
Python help() function is used to get help related to the object passed during the call. It takes an optional parameter and returns help information.

# Python | import() function
We use the import keyword to make code in one module available in another. Imports in Python are important for structuring your code effectively. Using imports properly will make you more productive, allowing you to reuse code while keeping your projects maintainable.

# Python | range() does not return an iterator
The range() returns an iterable, not an iterator. It can make iterators when iteration is necessary. It is not a generator. A generator expression evaluates to an iterator

# Coroutine in Python
A coroutine is a function that can be suspended and resumed. It is often defined as a generalized subroutine. A subroutine can be executed, starting at one point and finishing at another point.

# Python bit functions on int (bit_length, to_bytes and from_bytes)
* int.bit_length() Returns the number of bits required to represent an integer in binary, excluding the sign and leading zeros.

* int.to_bytes(length, byteorder, *, signed=False) Return an array of bytes representing an integer.

* int.from_bytes(bytes, byteorder, *, signed=False)
